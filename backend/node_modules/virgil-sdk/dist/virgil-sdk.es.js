import fetchPonyfill from 'fetch-ponyfill';
import fs from 'fs';
import path from 'path';
import crypto from 'crypto';
import mkdirp from 'mkdirp';
import rimraf from 'rimraf';

var BASE_64 = 'base64';
/**
 * Decodes the base64 encoded string into a `Buffer` or `string` depending on
 * the presence of `outputEncoding` parameter.
 * @hidden
 * @param {string} input
 * @param {string} [outputEncoding] - If provided, specifies the output string
 * encoding.
 * @returns {Buffer|string}
 */
function base64Decode(input, outputEncoding) {
    if (outputEncoding) {
        return Buffer.from(input, BASE_64).toString(outputEncoding);
    }
    return Buffer.from(input, BASE_64);
}
/**
 * Encodes the `input` bytes into a string using base64 encoding.
 * If `input` is a string, it is first converted to byte array by decoding
 * it using `inputEncoding`.
 * @hidden
 * @param {Buffer | string} input
 * @param {string} inputEncoding
 * @returns {string}
 */
function base64Encode(input, inputEncoding) {
    var buffer;
    if (Buffer.isBuffer(input)) {
        buffer = input;
    }
    else if (inputEncoding && Buffer.isEncoding(inputEncoding)) {
        buffer = Buffer.from(input, inputEncoding);
    }
    else {
        buffer = Buffer.from(input);
    }
    return buffer.toString(BASE_64);
}
/**
 * Converts regular base64 encoded string to URL-safe base64 encoded string.
 * @hidden
 * @param {string} input - Regular base64 encoded string.
 * @returns {string} - URL-safe base64 encoded string.
 */
function base64UrlFromBase64(input) {
    input = input.split('=')[0];
    input = input.replace(/\+/g, '-').replace(/\//g, '_');
    return input;
}
/**
 * Converts URL-safe base64 encoded string to regular base64 encoded string.
 * @hidden
 * @param {string} input - URL-safe base64 encoded string.
 * @returns {string} - Regular base64 encoded string.
 */
function base64UrlToBase64(input) {
    input = input.replace(/-/g, '+').replace(/_/g, '/');
    switch (input.length % 4) {
        case 0: break; // no padding needed
        case 2:
            input = input + '==';
            break;
        case 3:
            input = input + '=';
            break;
        default:
            throw new Error('Invalid base64 string');
    }
    return input;
}
/**
 * * Encodes the `input` bytes into a string using URL-safe base64 encoding.
 * If `input` is a string, it is first converted to byte array by decoding
 * it using `inputEncoding`.
 *
 * @hidden
 *
 * @param {string | Buffer} input - The input.
 * @param {string} inputEncoding - If `input` is a string, this parameter
 * specifies the encoding of the input string. If `input` is a `Buffer`, this
 * parameter is ignored.
 * @returns {string}
 */
function base64UrlEncode(input, inputEncoding) {
    var output = base64Encode(input, inputEncoding);
    return base64UrlFromBase64(output);
}
/**
 * Decodes the URL-safe base64-encoded `input` string into a `Buffer` or
 * `string` depending on the presence of `outputEncoding` parameter.
 *
 * @hidden
 *
 * @param {string} input
 * @param {string} [outputEncoding] - If provided, specifies the output string
 * encoding.
 * @returns {Buffer|string}
 */
function base64UrlDecode(input, outputEncoding) {
    input = base64UrlToBase64(input);
    if (outputEncoding) {
        return base64Decode(input, outputEncoding);
    }
    return base64Decode(input);
}

/**
 * Converts javascript date object or timestamp in milliseconds
 * to Unix timestamp.
 *
 * @hidden
 *
 * @param {Date | number} date - The date or timestamp to convert.
 * @returns {number}
 */
function getUnixTimestamp(date) {
    var time;
    if (typeof date === 'number') {
        time = date;
    }
    else {
        time = date.getTime();
    }
    return Math.floor(time / 1000);
}
/**
 * Adds the given number of seconds to the given date.
 *
 * @hidden
 *
 * @param {Date | number} date - The date to add seconds to.
 * If `date` is a `number` it is treated as a timestamp in milliseconds.
 * @param {number} seconds - The number of seconds to add.
 * @returns {Date} - The new date.
 */
function addSeconds(date, seconds) {
    if (typeof date === 'number') {
        return new Date(date + seconds * 1000);
    }
    return new Date(date.getTime() + seconds * 1000);
}

/**
 * JWT Subject.
 * @hidden
 */
var SubjectPrefix = "identity-";
/**
 * JWT Issuer.
 * @hidden
 */
var IssuerPrefix = "virgil-";
/**
 * Content type of the token. Used to convey structural information
 * about the JWT.
 * @hidden
 */
var VirgilContentType = "virgil-jwt;v=1";
/**
 * Media type of the JWT.
 * @hidden
 */
var JwtContentType = "JWT";

/**
 * Class representing the JWT providing access to the
 * Virgil Security APIs.
 * Implements {@link IAccessToken} interface.
 */
var Jwt = /** @class */ (function () {
    function Jwt(header, body, signature) {
        if (typeof header === 'string') {
            var stringRepresentation = header;
            var parts = stringRepresentation.split('.');
            if (parts.length !== 3)
                throw new Error('Wrong JWT format');
            try {
                this.header = JSON.parse(base64UrlDecode(parts[0], 'utf8'));
                this.body = JSON.parse(base64UrlDecode(parts[1], 'utf8'));
                this.signature = base64UrlToBase64(parts[2]);
            }
            catch (e) {
                throw new Error('Wrong JWT format');
            }
            this.unsignedData = parts[0] + '.' + parts[1];
            this.stringRepresentation = stringRepresentation;
        }
        else if (typeof header === 'object' && typeof body === 'object') {
            this.header = header;
            this.body = body;
            this.signature = signature;
            this.unsignedData = this.headerBase64() + '.' + this.bodyBase64();
            this.stringRepresentation = this.signature == null
                ? this.unsignedData
                : this.unsignedData + '.' + this.signatureBase64();
        }
        else {
            throw new TypeError('Invalid arguments for function Jwt. ' +
                'Expected a string representation of a token, or header and body as objects');
        }
    }
    /**
     * Parses the string representation of the JWT into
     * an object representation.
     *
     * @param {string} jwtStr - The JWT string. Must have the following format:
     *
     * `base64UrlEncode(Header) + "." + base64UrlEncode(Body) + "." + base64UrlEncode(Signature)`
     *
     * See the {@link https://jwt.io/introduction/ | Introduction to JWT} for more details.
     *
     * @returns {Jwt}
     */
    Jwt.fromString = function (jwtStr) {
        return new Jwt(jwtStr);
    };
    /**
     * Returns the string representation of this JWT.
     * @returns {string}
     */
    Jwt.prototype.toString = function () {
        return this.stringRepresentation;
    };
    /**
     * Retrieves the identity that is the subject of this JWT.
     * @returns {string}
     */
    Jwt.prototype.identity = function () {
        if (this.body.sub.indexOf(SubjectPrefix) !== 0) {
            throw new Error('wrong sub format');
        }
        return this.body.sub.substr(SubjectPrefix.length);
    };
    /**
     * Retrieves the application ID that is the issuer of this JWT.
     * @returns {string}
     */
    Jwt.prototype.appId = function () {
        if (this.body.iss.indexOf(IssuerPrefix) !== 0) {
            throw new Error('wrong iss format');
        }
        return this.body.iss.substr(IssuerPrefix.length);
    };
    /**
     * Returns a boolean indicating whether this JWT is (or will be)
     * expired at the given date or not.
     *
     * @param {Date} at - The date to check. Defaults to `new Date()`.
     * @returns {boolean} - `true` if token is expired, otherwise `false`.
     */
    Jwt.prototype.isExpired = function (at) {
        if (at === void 0) { at = new Date; }
        var now = getUnixTimestamp(at);
        return this.body.exp < now;
    };
    Jwt.prototype.headerBase64 = function () {
        return base64UrlEncode(JSON.stringify(this.header));
    };
    Jwt.prototype.bodyBase64 = function () {
        return base64UrlEncode(JSON.stringify(this.body));
    };
    Jwt.prototype.signatureBase64 = function () {
        return base64UrlFromBase64(this.signature);
    };
    return Jwt;
}());

/**
 * Test if `condition` is truthy. If it is not, an `Error` is thrown with a
 * `message` property equal to `message` parameter.
 * @hidden
 * @param {boolean} condition
 * @param {string} message
 */
function assert(condition, message) {
    if (!condition) {
        throw new Error(message);
    }
}

var DEFAULT_TOKEN_TTL = 20 * 60 * 1000; // 20 minutes
/**
 * Class responsible for JWT generation.
 */
var JwtGenerator = /** @class */ (function () {
    function JwtGenerator(options) {
        validateOptions(options);
        this.appId = options.appId;
        this.apiKey = options.apiKey;
        this.apiKeyId = options.apiKeyId;
        this.accessTokenSigner = options.accessTokenSigner;
        this.millisecondsToLive = options.millisecondsToLive !== undefined
            ? Number(options.millisecondsToLive)
            : DEFAULT_TOKEN_TTL;
    }
    /**
     * Generates a token with the given identity as the subject and optional
     * additional data.
     * @param {string} identity - Identity to be associated with JWT (i.e.
     * the Subject).
     * @param {IExtraData} ada - Additional data to be encoded in the JWT.
     * @returns {Jwt}
     */
    JwtGenerator.prototype.generateToken = function (identity, ada) {
        if (!identity) {
            throw new TypeError('Illegal arguments for function `generateToken`. Argument `identity` is required.');
        }
        var iat = getUnixTimestamp(new Date());
        var exp = getUnixTimestamp(new Date().getTime() + this.millisecondsToLive);
        var body = {
            iss: IssuerPrefix + this.appId,
            sub: SubjectPrefix + identity,
            iat: iat,
            exp: exp,
            ada: ada
        };
        var header = {
            alg: this.accessTokenSigner.getAlgorithm(),
            kid: this.apiKeyId,
            typ: JwtContentType,
            cty: VirgilContentType
        };
        var unsignedJwt = new Jwt(header, body);
        var signature = this.accessTokenSigner.generateTokenSignature(unsignedJwt.unsignedData, this.apiKey);
        return new Jwt(header, body, signature.toString('base64'));
    };
    return JwtGenerator;
}());
function validateOptions(opts) {
    var invalidOptionMessage = function (name) {
        return "Invalid JwtGenerator options. `" + name + "` is required";
    };
    assert(opts != null, 'JwtGenerator options must be provided');
    assert(opts.apiKey != null, invalidOptionMessage('apiKey'));
    assert(opts.apiKeyId != null, invalidOptionMessage('apiKeyId'));
    assert(opts.appId != null, invalidOptionMessage('appId'));
    assert(opts.accessTokenSigner != null, invalidOptionMessage('accessTokenSigner'));
}

/**
 * Class responsible for verification of JWTs.
 */
var JwtVerifier = /** @class */ (function () {
    function JwtVerifier(options) {
        validateOptions$1(options);
        this.accessTokenSigner = options.accessTokenSigner;
        this.apiPublicKey = options.apiPublicKey;
        this.apiKeyId = options.apiKeyId;
    }
    /**
     * Verifies the validity of the given JWT.
     * @param {Jwt} token - The JWT to verify.
     * @returns {boolean}
     */
    JwtVerifier.prototype.verifyToken = function (token) {
        if (token == null) {
            throw new Error('Token is empty');
        }
        if (!this.allFieldsAreCorrect(token)) {
            return false;
        }
        return this.accessTokenSigner.verifyTokenSignature(token.unsignedData, token.signature, this.apiPublicKey);
    };
    JwtVerifier.prototype.allFieldsAreCorrect = function (token) {
        return token.header.kid == this.apiKeyId
            && token.header.alg == this.accessTokenSigner.getAlgorithm()
            && token.header.cty == VirgilContentType
            && token.header.typ == JwtContentType;
    };
    return JwtVerifier;
}());
function validateOptions$1(opts) {
    var invalidOptionMessage = function (name) {
        return "Invalid JwtVerifier options. `" + name + "` is required";
    };
    assert(opts != null, 'JwtVerifier options must be provided');
    assert(opts.apiPublicKey != null, invalidOptionMessage('apiPublicKey'));
    assert(opts.apiKeyId != null, invalidOptionMessage('apiKeyId'));
    assert(opts.accessTokenSigner != null, invalidOptionMessage('accessTokenSigner'));
}

var TOKEN_EXPIRATION_MARGIN = 5;
/**
 * Implementation of {@link IAccessTokenProvider} that caches the JWT
 * in memory while it's fresh (i.e. not expired) and uses the user-provided
 * callback function to get the JWT when requested by the clients.
 */
var CachingJwtProvider = /** @class */ (function () {
    /**
     * Creates a new instance of `CachingJwtProvider`.
     * @param {GetJwtCallback} renewJwtFn - The function that will be called
     * whenever the fresh JWT is needed. If the `renewJwtFn` returns the JWT
     * as a string, it will be converted to {@link Jwt} instance automatically.
     * @param {Jwt|string} [initialToken] - Optional initial JWT.
     */
    function CachingJwtProvider(renewJwtFn, initialToken) {
        var _this = this;
        if (typeof renewJwtFn !== 'function') {
            throw new TypeError('`renewJwtFn` must be a function');
        }
        if (initialToken) {
            var jwt = void 0;
            if (typeof initialToken === 'string') {
                jwt = Jwt.fromString(initialToken);
            }
            else if (initialToken instanceof Jwt) {
                jwt = initialToken;
            }
            else {
                throw new Error("Expected \"initialToken\" to be a string or an instance of Jwt, got " + typeof initialToken);
            }
            this.cachedJwt = jwt;
        }
        this.getJwt = function (context) {
            if (_this.cachedJwt && !_this.cachedJwt.isExpired(addSeconds(new Date, TOKEN_EXPIRATION_MARGIN))) {
                return Promise.resolve(_this.cachedJwt);
            }
            if (_this.jwtPromise) {
                return _this.jwtPromise;
            }
            _this.jwtPromise = Promise.resolve(renewJwtFn(context))
                .then(function (token) {
                var jwt = typeof token === 'string' ? Jwt.fromString(token) : token;
                _this.cachedJwt = jwt;
                _this.jwtPromise = undefined;
                return jwt;
            }).catch(function (err) {
                _this.jwtPromise = undefined;
                throw err;
            });
            return _this.jwtPromise;
        };
    }
    /**
     * Returns a `Promise` resolved with the cached token if it's fresh, or the
     * token obtained by the call to the `renewJwtCallback` otherwise. The token
     * obtained from the `renewJwtCallback` is then cached. If the `renewJwtCallback`
     * returns the JWT as a string, it is converted to {@link Jwt} instance before returning.
     * @param {ITokenContext} context
     * @returns {Promise<IAccessToken>}
     */
    CachingJwtProvider.prototype.getToken = function (context) {
        return this.getJwt(context);
    };
    return CachingJwtProvider;
}());

/**
 * Implementation of {@link IAccessToken} that calls the user-provided
 * callback function to get the JWT when requested by the clients.
 */
var CallbackJwtProvider = /** @class */ (function () {
    /**
     * Creates a new instance of `CallbackJwtProvider`.
     *
     * @param {GetJwtCallback} getJwtFn - The function that will be called
     * whenever the JWT is needed. If the `getJwtFn` returns the JWT as a
     * string, it will be converted to {@link Jwt} instance automatically.
     */
    function CallbackJwtProvider(getJwtFn) {
        if (typeof getJwtFn !== 'function') {
            throw new TypeError('`getJwtFn` must be a function');
        }
        this.getJwt = function (context) {
            return Promise.resolve(getJwtFn(context))
                .then(function (token) { return typeof token === 'string' ? Jwt.fromString(token) : token; });
        };
    }
    /**
     * Returns a `Promise` resolved with the {@link Jwt} instance obtained
     * by the call to the {@link CallbackJwtProvider.getJwt}. If the
     * `getJwtFn` returns the JWT as a string, it is converted to
     * {@link Jwt} instance before returning.
     *
     * @param {ITokenContext} context
     * @returns {Promise<IAccessToken>}
     */
    CallbackJwtProvider.prototype.getToken = function (context) {
        return this.getJwt(context);
    };
    return CallbackJwtProvider;
}());

/**
 * Implementation of {@link IAccessTokenProvider} that returns a
 * user-provided constant access token whenever it is requested by the clients.
 */
var ConstAccessTokenProvider = /** @class */ (function () {
    /**
     * Creates a new instance of `ConstAccessTokenProvider`
     * @param {IAccessToken} accessToken - The access token to be returned
     * whenever it is requested.
     */
    function ConstAccessTokenProvider(accessToken) {
        this.accessToken = accessToken;
        if (accessToken == null) {
            throw new TypeError('`accessToken` is required');
        }
    }
    /**
     * Returns a `Promise` fulfilled with the
     * {@link ConstAccessTokenProvider.accessToken} provided to the constructor
     * of this instance.
     *
     * @param {ITokenContext} context
     * @returns {Promise<IAccessToken>}
     */
    ConstAccessTokenProvider.prototype.getToken = function (context) {
        return Promise.resolve(this.accessToken);
    };
    return ConstAccessTokenProvider;
}());

/**
 * Implementation of {@link IAccessTokenProvider} that generates a
 * new JWT whenever it is requested by the clients.
 *
 * This class is meant to be used on the server side only.
 */
var GeneratorJwtProvider = /** @class */ (function () {
    /**
     * Creates a new instance of `GeneratorJwtProvider` with the given
     * {@link JwtGenerator}, additional data and default identity.
     *
     * @param {JwtGenerator} jwtGenerator - Object to delegate the JWT generation to.
     * @param {IExtraData} additionalData - Additional data to include with the JWT.
     * @param {string} defaultIdentity - Identity of the user to include in the token
     * when none is provided explicitly by the client.
     */
    function GeneratorJwtProvider(jwtGenerator, additionalData, defaultIdentity) {
        this.jwtGenerator = jwtGenerator;
        this.additionalData = additionalData;
        this.defaultIdentity = defaultIdentity;
        if (jwtGenerator == null) {
            throw new TypeError('`jwtGenerator` is required');
        }
    }
    /**
     * Returns a `Promise` fulfilled with the JWT obtained from the call
     * to {@link GeneratorJwtProvider.jwtGenerator} {@link JwtGenerator.generateToken}
     * method, passing it the {@link GeneratorJwtProvider.additionalData} and
     * {@link GeneratorJwtProvider.defaultIdentity}
     *
     * @param {ITokenContext} context
     * @returns {Promise<IAccessToken>}
     */
    GeneratorJwtProvider.prototype.getToken = function (context) {
        var _this = this;
        return Promise.resolve().then(function () {
            var jwt = _this.jwtGenerator.generateToken(context.identity || _this.defaultIdentity || '', _this.additionalData);
            return jwt;
        });
    };
    return GeneratorJwtProvider;
}());

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
}

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

/**
 * Intermediate representation of the Virgil Card with `contentSnapshot`
 * and `snapshot`s of the signatures in UTF-8.
 */
var RawSignedModel = /** @class */ (function () {
    /**
     * Initializes a new instance of `RawSignedModel`.
     * @param {string} contentSnapshot - The content snapshot in UTF-8.
     * @param {IRawSignature[]} signatures - The signatures. If signatures
     * themselves have snapshots, those must also be in UTF-8.
     */
    function RawSignedModel(contentSnapshot, signatures) {
        this.contentSnapshot = contentSnapshot;
        this.signatures = signatures;
    }
    /**
     * Converts the `str` in base64 encoding into a `RawSignedModel` object.
     *
     * @param {string} str - Base64 string representation of the card as
     * returned by {@RawSignedModel.toString} method.
     *
     * @returns {RawSignedModel}
     */
    RawSignedModel.fromString = function (str) {
        var jsonStr = base64Decode(str, 'utf8');
        var obj;
        try {
            obj = JSON.parse(jsonStr);
        }
        catch (error) {
            throw new Error('The string to be parsed is in invalid format');
        }
        return RawSignedModel.fromJson(obj);
    };
    /**
     * Converts the `json` serializable object into a `RawSignedModel` object.
     * @param {IRawSignedModelJson} json - JSON-serializable object returned by
     * {@link RawSignedModel.toJson} method.
     * @returns {RawSignedModel}
     */
    RawSignedModel.fromJson = function (json) {
        var contentSnapshotUtf8 = base64Decode(json.content_snapshot, 'utf8');
        var signaturesWithUtf8Snapshots = (json.signatures || []).map(function (_a) {
            var signer = _a.signer, signature = _a.signature, snapshot = _a.snapshot;
            if (snapshot) {
                return {
                    signer: signer,
                    signature: signature,
                    snapshot: base64Decode(snapshot, 'utf8')
                };
            }
            return { signer: signer, signature: signature };
        });
        return new RawSignedModel(contentSnapshotUtf8, signaturesWithUtf8Snapshots);
    };
    /**
     * This is to make it work with `JSON.stringify`, calls
     * {@link RawSignedModel.toJson} under the hood.
     * @returns {IRawSignedModelJson}
     */
    RawSignedModel.prototype.toJSON = function () {
        return this.toJson();
    };
    /**
     * Returns a JSON-serializable representation of this model in the
     * format it is stored in the Virgil Cards Service. (i.e. with
     * `contentSnapshot` and `snapshot`s of the signatures as base64 encoded
     * strings.
     * @returns {IRawSignedModelJson}
     */
    RawSignedModel.prototype.toJson = function () {
        return {
            content_snapshot: base64Encode(this.contentSnapshot, 'utf8'),
            signatures: this.signatures.map(function (_a) {
                var signer = _a.signer, signature = _a.signature, snapshot = _a.snapshot;
                if (snapshot) {
                    return {
                        signer: signer,
                        signature: signature,
                        snapshot: base64Encode(snapshot, 'utf8')
                    };
                }
                return { signer: signer, signature: signature };
            })
        };
    };
    /**
     * Serializes this model to string in base64 encoding.
     * @returns {string}
     */
    RawSignedModel.prototype.toString = function () {
        return base64Encode(JSON.stringify(this), 'utf8');
    };
    /**
     * Same as {@link RawSignedModel.toJson}. Please use that instead.
     * @returns {IRawSignedModelJson}
     */
    RawSignedModel.prototype.exportAsJson = function () {
        return this.toJson();
    };
    /**
     * Same as {@link RawSignedModel.toString}. Please use that instead.
     * @returns {string}
     */
    RawSignedModel.prototype.exportAsString = function () {
        return this.toString();
    };
    return RawSignedModel;
}());

var _a = fetchPonyfill(), fetch = _a.fetch, Request = _a.Request, Response = _a.Response, Headers = _a.Headers;

/**
 * Class responsible for making HTTP requests.
 * @hidden
 */
var Connection = /** @class */ (function () {
    /**
     * Initializes a new instance of `Connection`.
     * @param {string} prefix - `prefix` will be prepended to the `endpoint`
     * argument of request methods.
     */
    function Connection(prefix) {
        this.prefix = prefix;
    }
    /**
     * Issues a GET request against the `endpoint`.
     * @param {string} endpoint - Endpoint URL relative to the `prefix`.
     * @param {string} accessToken - Token to authenticate the request.
     * @returns {Promise<Response>}
     */
    Connection.prototype.get = function (endpoint, accessToken) {
        var headers = this.createHeaders(accessToken);
        return this.send(endpoint, 'GET', { headers: headers });
    };
    /**
     * Issues a POST request against the `endpoint` sending the `data` as JSON.
     * @param {string} endpoint - Endpoint URL relative to the `prefix`.
     * @param {string} accessToken - Token to authenticate the request.
     * @param {object} data - Response body.
     * @returns {Promise<Response>}
     */
    Connection.prototype.post = function (endpoint, accessToken, data) {
        if (data === void 0) { data = {}; }
        var headers = this.createHeaders(accessToken);
        headers.set('Content-Type', 'application/json');
        return this.send(endpoint, 'POST', {
            headers: headers,
            body: JSON.stringify(data)
        });
    };
    Connection.prototype.send = function (endpoint, method, params) {
        return fetch(this.prefix + endpoint, __assign({ method: method }, params));
    };
    Connection.prototype.createHeaders = function (accessToken) {
        var headers = new Headers();
        headers.set('Authorization', "Virgil " + accessToken);
        return headers;
    };
    return Connection;
}());

/**
 * Custom error class for errors specific to Virgil SDK.
 */
var VirgilError = /** @class */ (function (_super) {
    __extends(VirgilError, _super);
    function VirgilError(m, name) {
        var _newTarget = this.constructor;
        if (name === void 0) { name = 'VirgilError'; }
        var _this = _super.call(this, m) || this;
        Object.setPrototypeOf(_this, _newTarget.prototype);
        _this.name = name;
        return _this;
    }
    return VirgilError;
}(Error));

var ErrorCode;
(function (ErrorCode) {
    ErrorCode[ErrorCode["AccessTokenExpired"] = 20304] = "AccessTokenExpired";
    ErrorCode[ErrorCode["Unknown"] = 0] = "Unknown";
})(ErrorCode || (ErrorCode = {}));
/**
 * Error thrown by {@link CardManager} when request to the Virgil Cards Service
 * fails.
 */
var VirgilHttpError = /** @class */ (function (_super) {
    __extends(VirgilHttpError, _super);
    function VirgilHttpError(message, status, errorCode) {
        var _this = _super.call(this, message, 'VirgilHttpError') || this;
        _this.httpStatus = status;
        _this.errorCode = errorCode;
        return _this;
    }
    return VirgilHttpError;
}(VirgilError));
/**
 * Generates error object from response object with HTTP status >= 400
 *
 * @hidden
 *
 * @param {Response} response
 * @returns {Promise<VirgilHttpError>}
 */
function generateErrorFromResponse(response) {
    return __awaiter(this, void 0, void 0, function () {
        var reason;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!(response.status >= 400 && response.status < 500)) return [3 /*break*/, 2];
                    return [4 /*yield*/, response.json()];
                case 1:
                    reason = _a.sent();
                    return [2 /*return*/, new VirgilHttpError(reason.message, response.status, reason.code)];
                case 2: return [2 /*return*/, new VirgilHttpError(response.statusText, response.status, 0)];
            }
        });
    });
}

var PublishEndpoint = '/card/v5';
var SearchEndpoint = '/card/v5/actions/search';
var GetCardEndpoint = function (cardId) { return "/card/v5/" + cardId; };
/**
 * Class responsible for sending requests to the Virgil Cards Service.
 *
 * @hidden
 */
var CardClient = /** @class */ (function () {
    /**
     * Initializes new instance of `CardClient`.
     * @param {IConnection | string} connection - Object implementing the
     * {@link IConnection} interface.
     */
    function CardClient(connection) {
        if (typeof connection === 'string') {
            this.connection = new Connection(connection);
        }
        else if (connection) {
            this.connection = connection;
        }
        else {
            this.connection = new Connection('https://api.virgilsecurity.com');
        }
    }
    /**
     * Issues a request to search cards by the `identity`.
     * @param {string[]} identities - Array of identities to search for.
     * @param {string} jwtToken - A token to authenticate the request.
     * @returns {Promise<RawSignedModel[]>}
     */
    CardClient.prototype.searchCards = function (identities, jwtToken) {
        return __awaiter(this, void 0, void 0, function () {
            var response, cardsJson;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.connection.post(SearchEndpoint, jwtToken, { identities: identities })];
                    case 1:
                        response = _a.sent();
                        if (!!response.ok) return [3 /*break*/, 3];
                        return [4 /*yield*/, generateErrorFromResponse(response)];
                    case 2: throw _a.sent();
                    case 3: return [4 /*yield*/, response.json()];
                    case 4:
                        cardsJson = _a.sent();
                        if (cardsJson === null)
                            return [2 /*return*/, []];
                        return [2 /*return*/, cardsJson.map(RawSignedModel.fromJson)];
                }
            });
        });
    };
    /**
     * Issues a request to get the card by id.
     * @param {string} cardId - Id of the card to fetch.
     * @param {string} jwtToken - A token to authenticate the request.
     * @returns {Promise<ICardResult>}
     */
    CardClient.prototype.getCard = function (cardId, jwtToken) {
        return __awaiter(this, void 0, void 0, function () {
            var response, isOutdated, cardJson, cardRaw;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!cardId)
                            throw new TypeError('`cardId` should not be empty');
                        if (!jwtToken)
                            throw new TypeError('`jwtToken` should not be empty');
                        return [4 /*yield*/, this.connection.get(GetCardEndpoint(cardId), jwtToken)];
                    case 1:
                        response = _a.sent();
                        if (!!response.ok) return [3 /*break*/, 3];
                        return [4 /*yield*/, generateErrorFromResponse(response)];
                    case 2: throw _a.sent();
                    case 3:
                        isOutdated = response.headers.get('X-Virgil-Is-Superseeded') === 'true';
                        return [4 /*yield*/, response.json()];
                    case 4:
                        cardJson = _a.sent();
                        cardRaw = RawSignedModel.fromJson(cardJson);
                        return [2 /*return*/, { cardRaw: cardRaw, isOutdated: isOutdated }];
                }
            });
        });
    };
    /**
     * Issues a request to publish the card.
     * @param {RawSignedModel} model - Card to publish.
     * @param {string} jwtToken - A token to authenticate the request.
     * @returns {Promise<RawSignedModel>}
     */
    CardClient.prototype.publishCard = function (model, jwtToken) {
        return __awaiter(this, void 0, void 0, function () {
            var response, cardJson;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!model)
                            throw new TypeError('`model` should not be empty');
                        if (!jwtToken)
                            throw new TypeError('`jwtToken` should not be empty');
                        return [4 /*yield*/, this.connection.post(PublishEndpoint, jwtToken, model)];
                    case 1:
                        response = _a.sent();
                        if (!!response.ok) return [3 /*break*/, 3];
                        return [4 /*yield*/, generateErrorFromResponse(response)];
                    case 2: throw _a.sent();
                    case 3: return [4 /*yield*/, response.json()];
                    case 4:
                        cardJson = _a.sent();
                        return [2 /*return*/, RawSignedModel.fromJson(cardJson)];
                }
            });
        });
    };
    return CardClient;
}());

/**
 * @hidden
 */
var SelfSigner = "self";
/**
 * @hidden
 */
var VirgilSigner = "virgil";
/**
 * @hidden
 */
var CardVersion = '5.0';
/**
 * @hidden
 */
var CardIdByteLength = 32;

/**
 * Class responsible for generating signatures of the cards.
 */
var ModelSigner = /** @class */ (function () {
    /**
     * Initializes a new instance of `ModelSigner`.
     * @param {ICardCrypto} crypto - Object implementing the
     * {@link ICardCrypto} interface.
     */
    function ModelSigner(crypto$$1) {
        this.crypto = crypto$$1;
    }
    /**
     * Generates a new signature based on `rawParams`.
     * @param {IRawSignParams} rawParams
     */
    ModelSigner.prototype.sign = function (rawParams) {
        var _a = this.prepareParams(rawParams), model = _a.model, signerPrivateKey = _a.signerPrivateKey, signer = _a.signer, extraSnapshot = _a.extraSnapshot;
        var signedSnapshot = extraSnapshot != null
            ? model.contentSnapshot + extraSnapshot
            : model.contentSnapshot;
        var signature = this.crypto.generateSignature(signedSnapshot, signerPrivateKey);
        model.signatures.push({
            signer: signer,
            signature: signature.toString('base64'),
            snapshot: extraSnapshot
        });
    };
    ModelSigner.prototype.prepareParams = function (_a) {
        var model = _a.model, signerPrivateKey = _a.signerPrivateKey, extraFields = _a.extraFields, signer = _a.signer;
        signer = signer || SelfSigner;
        var extraSnapshot;
        if (extraFields != null) {
            extraSnapshot = JSON.stringify(extraFields);
        }
        var final = { model: model, signerPrivateKey: signerPrivateKey, signer: signer, extraSnapshot: extraSnapshot };
        this.validate(final);
        return final;
    };
    ModelSigner.prototype.validate = function (_a) {
        var model = _a.model, signerPrivateKey = _a.signerPrivateKey, signer = _a.signer;
        if (model == null) {
            throw new Error("Model is empty");
        }
        if (signerPrivateKey == null) {
            throw new Error("`signerPrivateKey` property is mandatory");
        }
        if (model.signatures != null && model.signatures.some(function (s) { return s.signer == signer; })) {
            throw new Error("The model already has this signature.");
        }
    };
    return ModelSigner;
}());

/**
 * Converts an {@link ICard} to a {@link RawSignedModel}.
 *
 * @hidden
 *
 * @param {ICard} card - The {@link ICard} to convert.
 * @returns {RawSignedModel}
 */
function cardToRawSignedModel(card) {
    return new RawSignedModel(card.contentSnapshot, card.signatures.slice());
}
/**
 * Generates a {@link RawSignedModel} from the given `params`.
 *
 * @hidden
 *
 * @param {ICardCrypto} crypto - Object implementing the {@link ICardCrypto}
 * interface.
 * @param {INewCardParams} params - New card parameters.
 * @returns {RawSignedModel}
 */
function generateRawSigned(crypto$$1, params) {
    var identity = params.identity, publicKey = params.publicKey, previousCardId = params.previousCardId;
    var now = getUnixTimestamp(new Date);
    var details = {
        identity: identity,
        previous_card_id: previousCardId,
        created_at: now,
        version: CardVersion,
        public_key: base64Encode(crypto$$1.exportPublicKey(publicKey))
    };
    return new RawSignedModel(JSON.stringify(details), []);
}
/**
 * Converts the {@link RawSignedModel} into the {@link ICard}.
 *
 * @hidden
 *
 * @param {ICardCrypto} crypto - Object implementing the {@link ICardCrypto}
 * interface.
 * @param {RawSignedModel} model - The model to convert.
 * @param {boolean} isOutdated - Boolean indicating whether there is a newer
 * Virgil Card replacing the one that `model` represents.
 *
 * @returns {ICard}
 */
function parseRawSignedModel(crypto$$1, model, isOutdated) {
    if (isOutdated === void 0) { isOutdated = false; }
    var content = JSON.parse(model.contentSnapshot);
    var signatures = model.signatures.map(rawSignToCardSign);
    return {
        id: generateCardId(crypto$$1, model.contentSnapshot),
        publicKey: crypto$$1.importPublicKey(content.public_key),
        contentSnapshot: model.contentSnapshot,
        identity: content.identity,
        version: content.version,
        createdAt: new Date(content.created_at * 1000),
        previousCardId: content.previous_card_id,
        signatures: signatures,
        isOutdated: isOutdated
    };
}
/**
 * Given the array of `cards`, returns another array with outdated cards
 * filtered out and the `previousCard` properties of the cards that replace
 * the outdated ones being populated with appropriate outdated cards.
 * i.e. turns this (A is for Actual, O is for Outdated):
 * ```
 * A -> O -> A -> A -> O
 * ```
 * into this
 * ```
 * A -> A -> A
 * |         |
 * O         O
 * ```
 *
 * @hidden
 *
 * @param {ICard[]} cards - The cards array to transform.
 * @returns {ICard[]} - Transformed array.
 */
function linkedCardList(cards) {
    var unsorted = Object.create(null);
    for (var _i = 0, cards_1 = cards; _i < cards_1.length; _i++) {
        var card = cards_1[_i];
        unsorted[card.id] = card;
    }
    for (var _a = 0, cards_2 = cards; _a < cards_2.length; _a++) {
        var card = cards_2[_a];
        if (card.previousCardId == null)
            continue;
        if (unsorted[card.previousCardId] == null)
            continue;
        unsorted[card.previousCardId].isOutdated = true;
        card.previousCard = unsorted[card.previousCardId];
        delete unsorted[card.previousCardId];
    }
    return Object.keys(unsorted).map(function (key) { return unsorted[key]; });
}
/**
 * Calculates ID for the VirgilCard from the `snapshot` of its contents.
 *
 * @hidden
 *
 * @param {ICardCrypto} crypto - Object implementing the {@link ICardCrypto}
 * interface.
 * @param {string} snapshot - The VirgilCard's contents snapshot.
 * @returns {string} - VirgilCard's ID encoded in HEX.
 */
function generateCardId(crypto$$1, snapshot) {
    var fingerprint = crypto$$1.generateSha512(snapshot).slice(0, CardIdByteLength);
    return fingerprint.toString('hex');
}
function rawSignToCardSign(_a) {
    var snapshot = _a.snapshot, signature = _a.signature, signer = _a.signer;
    return {
        signer: signer,
        signature: signature,
        snapshot: snapshot,
        extraFields: tryParseExtraFields(snapshot)
    };
}
function tryParseExtraFields(snapshot) {
    if (snapshot) {
        try {
            return JSON.parse(snapshot);
        }
        catch (ignored) { }
    }
    return {};
}

/**
 * Error thrown by {@link CardManager} instances when the card received from
 * the network (or imported from string\json) fails verification.
 */
var VirgilCardVerificationError = /** @class */ (function (_super) {
    __extends(VirgilCardVerificationError, _super);
    function VirgilCardVerificationError(m) {
        return _super.call(this, m, 'CardVerificationError') || this;
    }
    return VirgilCardVerificationError;
}(VirgilError));

/**
 * @hidden
 */
var throwingAccessTokenProvider = {
    getToken: function () {
        throw new Error('Please set `CardManager.accessTokenProvider` to be able to make requests.');
    }
};
/**
 * Class responsible for creating, publishing and retrieving Virgil Cards.
 */
var CardManager = /** @class */ (function () {
    function CardManager(params) {
        this.crypto = params.cardCrypto;
        this.client = new CardClient(params.apiUrl);
        this.modelSigner = new ModelSigner(params.cardCrypto);
        this.signCallback = params.signCallback;
        this.retryOnUnauthorized = params.retryOnUnauthorized;
        this.cardVerifier = params.cardVerifier;
        this.accessTokenProvider = params.accessTokenProvider || throwingAccessTokenProvider;
    }
    /**
     * Generates a {@link RawSignedModel} that represents a card from
     * `cardParams`.
     * Use this method if you don't need to publish the card right away, for
     * example if you need to first send it to your backend server to apply
     * additional signature.
     *
     * @param {INewCardParams} cardParams - New card parameters.
     * @returns {RawSignedModel}
     */
    CardManager.prototype.generateRawCard = function (cardParams) {
        var model = generateRawSigned(this.crypto, cardParams);
        this.modelSigner.sign({
            model: model,
            signerPrivateKey: cardParams.privateKey,
            signer: SelfSigner,
            extraFields: cardParams.extraFields
        });
        return model;
    };
    /**
     * Generates a card from `cardParams` and publishes it in the Virgil Cards
     * Service.
     * @param {INewCardParams} cardParams - New card parameters.
     * @returns {Promise<ICard>}
     */
    CardManager.prototype.publishCard = function (cardParams) {
        return __awaiter(this, void 0, void 0, function () {
            var tokenContext, token, rawSignedModel;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        validateCardParams(cardParams);
                        tokenContext = { identity: cardParams.identity, operation: 'publish' };
                        return [4 /*yield*/, this.accessTokenProvider.getToken(tokenContext)];
                    case 1:
                        token = _a.sent();
                        rawSignedModel = this.generateRawCard(Object.assign({}, cardParams, { identity: token.identity() }));
                        return [4 /*yield*/, this.publishRawSignedModel(rawSignedModel, tokenContext, token)];
                    case 2: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Publishes a previously generated card in the form of
     * {@link RawSignedModel} object.
     *
     * @param {RawSignedModel} rawCard - The card to publish.
     * @returns {Promise<ICard>}
     */
    CardManager.prototype.publishRawCard = function (rawCard) {
        return __awaiter(this, void 0, void 0, function () {
            var cardDetails, tokenContext, token;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        assert(rawCard != null && rawCard.contentSnapshot != null, '`rawCard` should not be empty');
                        cardDetails = JSON.parse(rawCard.contentSnapshot);
                        tokenContext = { identity: cardDetails.identity, operation: 'publish' };
                        return [4 /*yield*/, this.accessTokenProvider.getToken(tokenContext)];
                    case 1:
                        token = _a.sent();
                        return [2 /*return*/, this.publishRawSignedModel(rawCard, tokenContext, token)];
                }
            });
        });
    };
    /**
     * Fetches the card by `cardId` from the Virgil Card Service.
     * @param {string} cardId - Id of the card to fetch.
     * @returns {Promise<ICard>}
     */
    CardManager.prototype.getCard = function (cardId) {
        return __awaiter(this, void 0, void 0, function () {
            var tokenContext, accessToken, cardWithStatus, card;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        tokenContext = { operation: 'get' };
                        return [4 /*yield*/, this.accessTokenProvider.getToken(tokenContext)];
                    case 1:
                        accessToken = _a.sent();
                        return [4 /*yield*/, this.tryDo(tokenContext, accessToken, function (token) { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, this.client.getCard(cardId, token.toString())];
                                    case 1: return [2 /*return*/, _a.sent()];
                                }
                            }); }); })];
                    case 2:
                        cardWithStatus = _a.sent();
                        card = parseRawSignedModel(this.crypto, cardWithStatus.cardRaw, cardWithStatus.isOutdated);
                        if (card.id !== cardId) {
                            throw new VirgilCardVerificationError('Received invalid card');
                        }
                        this.validateCards([card]);
                        return [2 /*return*/, card];
                }
            });
        });
    };
    /**
     * Fetches collection of cards with the given `identity` from the Virgil
     * Cards Service.
     * @param {string|string[]} identities - Identity or an array of identities of the cards to fetch.
     * @returns {Promise<ICard[]>}
     */
    CardManager.prototype.searchCards = function (identities) {
        return __awaiter(this, void 0, void 0, function () {
            var identitiesArr, tokenContext, accessToken, rawCards, cards, identitiesSet;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!identities)
                            throw new TypeError('Argument `identities` is required');
                        identitiesArr = Array.isArray(identities) ? identities : [identities];
                        if (identitiesArr.length === 0)
                            throw new TypeError('Identities array must not be empty');
                        tokenContext = { operation: 'search' };
                        return [4 /*yield*/, this.accessTokenProvider.getToken(tokenContext)];
                    case 1:
                        accessToken = _a.sent();
                        return [4 /*yield*/, this.tryDo(tokenContext, accessToken, function (token) { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, this.client.searchCards(identitiesArr, token.toString())];
                                    case 1: return [2 /*return*/, _a.sent()];
                                }
                            }); }); })];
                    case 2:
                        rawCards = _a.sent();
                        cards = rawCards.map(function (raw) { return parseRawSignedModel(_this.crypto, raw, false); });
                        identitiesSet = new Set(identitiesArr);
                        if (cards.some(function (c) { return !identitiesSet.has(c.identity); })) {
                            throw new VirgilCardVerificationError('Received invalid cards');
                        }
                        this.validateCards(cards);
                        return [2 /*return*/, linkedCardList(cards)];
                }
            });
        });
    };
    /**
     * Converts the card in the form of {@link RawSignedModel} object to the
     * {@link ICard} object.
     *
     * @see {@link CardManager.exportCard}
     *
     * @param {RawSignedModel} rawCard - The card to convert.
     * @returns {ICard}
     */
    CardManager.prototype.importCard = function (rawCard) {
        var card = parseRawSignedModel(this.crypto, rawCard);
        this.validateCards([card]);
        return card;
    };
    /**
     * Converts the card in the base64 string form to the {@link ICard} object.
     *
     * @see {@link CardManager.exportCardAsString}
     *
     * @param {string} str - The string in base64.
     * @returns {ICard}
     */
    CardManager.prototype.importCardFromString = function (str) {
        assert(Boolean(str), '`str` should not be empty');
        return this.importCard(RawSignedModel.fromString(str));
    };
    /**
     * Converts the card in the JSON-serializable object form to the
     * {@link ICard} object.
     *
     * @see {@link CardManager.exportCardAsJson}
     *
     * @param {IRawSignedModelJson} json
     * @returns {ICard}
     */
    CardManager.prototype.importCardFromJson = function (json) {
        assert(Boolean(json), '`json` should not be empty');
        return this.importCard(RawSignedModel.fromJson(json));
    };
    /**
     * Converts the card in the form of {@link ICard} object to the
     * {@link RawSignedModel} object.
     *
     * @see {@link CardManager.importCard}
     *
     * @param {ICard} card
     * @returns {RawSignedModel}
     */
    CardManager.prototype.exportCard = function (card) {
        return cardToRawSignedModel(card);
    };
    /**
     * Converts the card in the form of {@link ICard} object to the string
     * in base64 encoding.
     *
     * @see {@link CardManager.importCardFromString}
     *
     * @param {ICard} card
     * @returns {string}
     */
    CardManager.prototype.exportCardAsString = function (card) {
        return this.exportCard(card).toString();
    };
    /**
     * Converts the card in the form of {@link ICard} object to the
     * JSON-serializable object form.
     *
     * @see {@link CardManager.importCardFromJson}
     *
     * @param {ICard} card
     * @returns {IRawSignedModelJson}
     */
    CardManager.prototype.exportCardAsJson = function (card) {
        return this.exportCard(card).toJson();
    };
    /**
     * @hidden
     */
    CardManager.prototype.publishRawSignedModel = function (rawCard, context, accessToken) {
        return __awaiter(this, void 0, void 0, function () {
            var publishedModel, card;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(this.signCallback != null)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.signCallback(rawCard)];
                    case 1:
                        rawCard = _a.sent();
                        _a.label = 2;
                    case 2: return [4 /*yield*/, this.tryDo(context, accessToken, function (token) { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.client.publishCard(rawCard, token.toString())];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        }); }); })];
                    case 3:
                        publishedModel = _a.sent();
                        if (rawCard.contentSnapshot !== publishedModel.contentSnapshot) {
                            throw new VirgilCardVerificationError('Received invalid card');
                        }
                        card = parseRawSignedModel(this.crypto, publishedModel);
                        this.validateCards([card]);
                        return [2 /*return*/, card];
                }
            });
        });
    };
    /**
     * @hidden
     */
    CardManager.prototype.tryDo = function (context, token, func) {
        return __awaiter(this, void 0, void 0, function () {
            var e_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 6]);
                        return [4 /*yield*/, func(token)];
                    case 1: return [2 /*return*/, _a.sent()];
                    case 2:
                        e_1 = _a.sent();
                        if (!(e_1 instanceof VirgilHttpError &&
                            e_1.httpStatus === 401 &&
                            e_1.errorCode === ErrorCode.AccessTokenExpired &&
                            this.retryOnUnauthorized)) return [3 /*break*/, 5];
                        return [4 /*yield*/, this.accessTokenProvider.getToken({
                                identity: context.identity,
                                operation: context.operation,
                                forceReload: true
                            })];
                    case 3:
                        token = _a.sent();
                        return [4 /*yield*/, func(token)];
                    case 4: return [2 /*return*/, _a.sent()];
                    case 5: throw e_1;
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Delegates to the {@link CardManager.cardVerifier} to verify the validity
     * of the `cards`.
     *
     * @throws {@link VirgilCardVerificationError} if any of the cards is not
     * valid.
     *
     * @param {ICard[]} cards
     */
    CardManager.prototype.validateCards = function (cards) {
        if (this.cardVerifier == null)
            return;
        for (var _i = 0, cards_1 = cards; _i < cards_1.length; _i++) {
            var card = cards_1[_i];
            if (!this.cardVerifier.verifyCard(card)) {
                throw new VirgilCardVerificationError('Validation errors have been detected');
            }
        }
    };
    return CardManager;
}());
/**
 * @hidden
 */
function validateCardParams(params, validateIdentity) {
    if (validateIdentity === void 0) { validateIdentity = false; }
    assert(params != null, 'Card parameters must be provided');
    assert(params.privateKey != null, 'Card\'s private key is required');
    assert(params.publicKey != null, 'Card\'s public key is required');
    if (validateIdentity) {
        assert(typeof params.identity === 'string' && params.identity !== '', 'Card\'s identity is required');
    }
}

var DEFAULTS = {
    verifySelfSignature: true,
    verifyVirgilSignature: true,
    whitelists: []
};
var VIRGIL_CARDS_PUBKEY_BASE64 = 'MCowBQYDK2VwAyEAljOYGANYiVq1WbvVvoYIKtvZi2ji9bAhxyu6iV/LF8M=';
/**
 * Class responsible for validating cards by verifying their digital
 * signatures.
 */
var VirgilCardVerifier = /** @class */ (function () {
    /**
     * Initializes a new instance of `VirgilCardVerifier`.
     * @param {ICardCrypto} crypto - Object implementing the
     * {@link ICardCrypto} interface.
     * @param {IVirgilCardVerifierParams} options - Initialization options.
     */
    function VirgilCardVerifier(crypto$$1, options) {
        this.crypto = crypto$$1;
        var params = __assign({}, DEFAULTS, (options || {}));
        this.verifySelfSignature = params.verifySelfSignature;
        this.verifyVirgilSignature = params.verifyVirgilSignature;
        this.whitelists = params.whitelists;
        this.virgilCardsPublicKey = crypto$$1.importPublicKey(VIRGIL_CARDS_PUBKEY_BASE64);
    }
    /**
     * Verifies the signatures of the `card`.
     * @param {ICard} card
     * @returns {boolean} `true` if the signatures to be verified are present
     * and valid, otherwise `false`.
     */
    VirgilCardVerifier.prototype.verifyCard = function (card) {
        var _this = this;
        if (this.selfValidationFailed(card)) {
            return false;
        }
        if (this.virgilValidationFailed(card)) {
            return false;
        }
        if (!this.whitelists || this.whitelists.length === 0) {
            return true;
        }
        var signers = card.signatures.map(function (s) { return s.signer; });
        for (var _i = 0, _a = this.whitelists; _i < _a.length; _i++) {
            var whitelist = _a[_i];
            if (whitelist == null || whitelist.length === 0) {
                return false;
            }
            var intersectedCreds = whitelist.filter(function (x) { return signers.indexOf(x.signer) !== -1; });
            if (intersectedCreds.length === 0) {
                return false;
            }
            var isValidForSome = intersectedCreds.some(function (cred) {
                return _this.validateSignerSignature(card, _this.getPublicKey(cred.publicKeyBase64), cred.signer);
            });
            if (!isValidForSome) {
                return false;
            }
        }
        return true;
    };
    VirgilCardVerifier.prototype.selfValidationFailed = function (card) {
        return this.verifySelfSignature
            && !this.validateSignerSignature(card, card.publicKey, SelfSigner);
    };
    VirgilCardVerifier.prototype.virgilValidationFailed = function (card) {
        return this.verifyVirgilSignature
            && !this.validateSignerSignature(card, this.virgilCardsPublicKey, VirgilSigner);
    };
    VirgilCardVerifier.prototype.getPublicKey = function (signerPublicKeyBase64) {
        return this.crypto.importPublicKey(signerPublicKeyBase64);
    };
    VirgilCardVerifier.prototype.validateSignerSignature = function (card, signerPublicKey, signer) {
        var signature = card.signatures.find(function (s) { return s.signer === signer; });
        if (signature == null)
            return false;
        var extendedSnapshot = signature.snapshot == null
            ? card.contentSnapshot
            : card.contentSnapshot + signature.snapshot;
        return this.crypto.verifySignature(extendedSnapshot, signature.signature, signerPublicKey);
    };
    return VirgilCardVerifier;
}());

/**
 * Error thrown by {@link IStorageAdapter.store} method when saving a value
 * with a key that already exists in store.
 */
var StorageEntryAlreadyExistsError = /** @class */ (function (_super) {
    __extends(StorageEntryAlreadyExistsError, _super);
    function StorageEntryAlreadyExistsError(key) {
        return _super.call(this, "Storage entry " + (key ? 'with key ' + name : 'with the given key') + "already exists", 'StorageEntryAlreadyExistsError') || this;
    }
    return StorageEntryAlreadyExistsError;
}(VirgilError));

var NO_SUCH_FILE = 'ENOENT';
var FILE_EXISTS = 'EEXIST';
/**
 * Implementation of {@link IStorageAdapter} that uses file system for
 * persistence. For use in Node.js.
 */
var FileSystemStorageAdapter = /** @class */ (function () {
    /**
     * Initializes a new instance of `FileSystemStorageAdapter`.
     * @param {IStorageAdapterConfig} config - Configuration options.
     * Currently only `dir` is supported and must be a file system path
     * to the folder where the data will be stored.
     */
    function FileSystemStorageAdapter(config) {
        this.config = config;
        mkdirp.sync(path.resolve(this.config.dir));
    }
    /**
     * @inheritDoc
     */
    FileSystemStorageAdapter.prototype.store = function (key, data) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var file = _this.resolveFilePath(key);
            fs.writeFile(file, data, { flag: 'wx' }, function (err) {
                if (err && err.code === FILE_EXISTS) {
                    return reject(new StorageEntryAlreadyExistsError());
                }
                resolve();
            });
        });
    };
    /**
     * @inheritDoc
     */
    FileSystemStorageAdapter.prototype.load = function (key) {
        var _this = this;
        return Promise.resolve().then(function () {
            var filename = _this.resolveFilePath(key);
            return readFileAsync(filename);
        });
    };
    /**
     * @inheritDoc
     */
    FileSystemStorageAdapter.prototype.exists = function (key) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var file = _this.resolveFilePath(key);
            fs.access(file, function (err) {
                if (err) {
                    if (err.code === NO_SUCH_FILE) {
                        return resolve(false);
                    }
                    return reject(err);
                }
                resolve(true);
            });
        });
    };
    /**
     * @inheritDoc
     */
    FileSystemStorageAdapter.prototype.remove = function (key) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var file = _this.resolveFilePath(key);
            fs.unlink(file, function (err) {
                if (err) {
                    if (err.code === NO_SUCH_FILE) {
                        return resolve(false);
                    }
                    return reject(err);
                }
                resolve(true);
            });
        });
    };
    /**
     * @inheritDoc
     */
    FileSystemStorageAdapter.prototype.update = function (key, data) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var file = _this.resolveFilePath(key);
            fs.writeFile(file, data, { flag: 'w' }, function (err) {
                if (err) {
                    return reject(err);
                }
                resolve();
            });
        });
    };
    /**
     * @inheritDoc
     */
    FileSystemStorageAdapter.prototype.clear = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            rimraf(_this.config.dir, function (err) {
                if (err) {
                    return reject(err);
                }
                resolve();
            });
        });
    };
    /**
     * @inheritDoc
     */
    FileSystemStorageAdapter.prototype.list = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            fs.readdir(_this.config.dir, function (err, files) {
                if (err) {
                    return reject(err);
                }
                Promise.all(files.map(function (filename) {
                    return readFileAsync(path.resolve(_this.config.dir, filename));
                })).then(function (contents) {
                    var entries = contents
                        .filter(function (content) { return content !== null; })
                        .map(function (content) { return content; });
                    resolve(entries);
                }).catch(reject);
            });
        });
    };
    FileSystemStorageAdapter.prototype.resolveFilePath = function (key) {
        return path.resolve(this.config.dir, this.hash(key));
    };
    FileSystemStorageAdapter.prototype.hash = function (data) {
        return crypto
            .createHash('sha256')
            .update(data)
            .digest('hex');
    };
    return FileSystemStorageAdapter;
}());
function readFileAsync(filename) {
    return new Promise(function (resolve, reject) {
        fs.readFile(filename, function (err, data) {
            if (err) {
                if (err.code === NO_SUCH_FILE) {
                    return resolve(null);
                }
                return reject(err);
            }
            resolve(data);
        });
    });
}

/**
 * {@link FileSystemStorageAdapter} or {@link IndexedDbStorageAdapter}
 * depending on the target platform (node or browser).
 */

/**
 * Error thrown from {@link PrivateKeyStorage.save} method when saving
 * a private key with a name that already exists in store.
 */
var PrivateKeyExistsError = /** @class */ (function (_super) {
    __extends(PrivateKeyExistsError, _super);
    function PrivateKeyExistsError(message) {
        if (message === void 0) { message = 'Private key with same name already exists'; }
        return _super.call(this, message, 'PrivateKeyExistsError') || this;
    }
    return PrivateKeyExistsError;
}(VirgilError));

var DEFAULTS$1 = {
    dir: '.virgil_keys',
    name: 'VirgilKeys'
};
/**
 * Class representing a storage container for private key data.
 * Use this class if you need to load the keys stored with
 * version 4.x of this library. For new code, use the
 * {@link PrivateKeyStorage} instead.
 *
 * @deprecated since version 5.0
 */
var KeyStorage = /** @class */ (function () {
    function KeyStorage(config) {
        if (config === void 0) { config = {}; }
        console.log('Warning! `KeyStorage` is deprecated. Use `PrivateKeyStorage` instead.');
        this.adapter = resolveAdapter(config);
    }
    /**
     * Checks whether a private key data with the given name exist in persistent storage.
     * @param {string} name - Name to check.
     * @returns {Promise<boolean>} - True if key data exist, otherwise false.
     */
    KeyStorage.prototype.exists = function (name) {
        validateName(name);
        return this.adapter.exists(name);
    };
    /**
     * Loads the private key data by the given name.
     * @param {string} name - Name of key data to load.
     * @returns {Promise<Buffer | null>} - Private key data as Buffer,
     * or null if there is no data for the given name.
     */
    KeyStorage.prototype.load = function (name) {
        validateName(name);
        return this.adapter.load(name);
    };
    /**
     * Removes the private key data stored under the given name from persistent storage.
     * @param {string} name - Name of the key data to remove.
     * @returns {Promise<boolean>} - True if the key has been removed, otherwise false.
     */
    KeyStorage.prototype.remove = function (name) {
        validateName(name);
        return this.adapter.remove(name);
    };
    /**
     * Persists the private key data under the given name.
     * @param {string} name - Name of the key data.
     * @param {Buffer} data - The key data.
     * @returns {Promise<void>}
     */
    KeyStorage.prototype.save = function (name, data) {
        validateName(name);
        validateData(data);
        return this.adapter.store(name, data)
            .catch(function (error) {
            if (error && error.code === 'EEXIST') {
                return Promise.reject(new PrivateKeyExistsError());
            }
            return Promise.reject(error);
        });
    };
    return KeyStorage;
}());
function resolveAdapter(config) {
    if (typeof config === 'string') {
        return new FileSystemStorageAdapter({ dir: config, name: config });
    }
    var adapter = config.adapter, rest = __rest(config, ["adapter"]);
    if (adapter != null) {
        return adapter;
    }
    return new FileSystemStorageAdapter(__assign({}, DEFAULTS$1, rest));
}
function validateName(name) {
    if (!name)
        throw new TypeError('Argument `name` is required.');
}
function validateData(data) {
    if (!data)
        throw new TypeError('Argument `data` is required.');
}

/**
 * Error thrown when the value loaded from persistent storage cannot be
 * parsed as a {@link IKeyEntry} object.
 */
var InvalidKeyEntryError = /** @class */ (function (_super) {
    __extends(InvalidKeyEntryError, _super);
    function InvalidKeyEntryError(message) {
        if (message === void 0) { message = 'Loaded key entry was in invalid format.'; }
        return _super.call(this, message, 'InvalidKeyEntryError') || this;
    }
    return InvalidKeyEntryError;
}(VirgilError));
/**
 * Error thrown from {@link KeyEntryStorage.save} method when saving a
 * a key entry with the name that already exists in store.
 */
var KeyEntryAlreadyExistsError = /** @class */ (function (_super) {
    __extends(KeyEntryAlreadyExistsError, _super);
    function KeyEntryAlreadyExistsError(name) {
        return _super.call(this, "Key entry " + (name ? 'named ' + name : 'with same name') + "already exists", 'KeyEntryAlreadyExistsError') || this;
    }
    return KeyEntryAlreadyExistsError;
}(VirgilError));
/**
 * Error thrown from {@link KeyEntryStorage.update} method when updating
 * a key entry that doesn't exist in store.
 */
var KeyEntryDoesNotExistError = /** @class */ (function (_super) {
    __extends(KeyEntryDoesNotExistError, _super);
    function KeyEntryDoesNotExistError(name) {
        return _super.call(this, "Key entry " + (name ? 'named ' + name : 'with the given name') + " does not exist.", 'KeyEntryDoesNotExistError') || this;
    }
    return KeyEntryDoesNotExistError;
}(VirgilError));

var DEFAULTS$2 = {
    dir: '.virgil_key_entries',
    name: 'VirgilKeyEntries'
};
var VALUE_KEY = 'value';
var CREATION_DATE_KEY = 'creationDate';
var MODIFICATION_DATE_KEY = 'modificationDate';
/**
 * Class responsible for persisting private key bytes with optional
 * user-defined metadata.
 */
var KeyEntryStorage = /** @class */ (function () {
    /**
     * Initializes a new instance of `KeyEntryStorage`.
     *
     * @param {IKeyEntryStorageConfig} config - Instance configuration.
     */
    function KeyEntryStorage(config) {
        if (config === void 0) { config = {}; }
        this.adapter = resolveAdapter$1(config);
    }
    /**
     * @inheritDoc
     */
    KeyEntryStorage.prototype.exists = function (name) {
        validateName$1(name);
        return this.adapter.exists(name);
    };
    /**
     * @inheritDoc
     */
    KeyEntryStorage.prototype.load = function (name) {
        validateName$1(name);
        return this.adapter.load(name).then(function (data) {
            if (data == null) {
                return null;
            }
            return deserializeKeyEntry(data);
        });
    };
    /**
     * @inheritDoc
     */
    KeyEntryStorage.prototype.remove = function (name) {
        validateName$1(name);
        return this.adapter.remove(name);
    };
    /**
     * @inheritDoc
     */
    KeyEntryStorage.prototype.save = function (_a) {
        var name = _a.name, value = _a.value, meta = _a.meta;
        validateNameProperty(name);
        validateValueProperty(value);
        var keyEntry = {
            name: name,
            value: value,
            meta: meta,
            creationDate: new Date(),
            modificationDate: new Date()
        };
        return this.adapter.store(name, serializeKeyEntry(keyEntry))
            .then(function () { return keyEntry; })
            .catch(function (error) {
            if (error && error.name === 'StorageEntryAlreadyExistsError') {
                throw new KeyEntryAlreadyExistsError(name);
            }
            throw error;
        });
    };
    /**
     * @inheritDoc
     */
    KeyEntryStorage.prototype.list = function () {
        return this.adapter.list()
            .then(function (entries) { return entries.map(function (entry) { return deserializeKeyEntry(entry); }); });
    };
    /**
     * @inheritDoc
     */
    KeyEntryStorage.prototype.update = function (_a) {
        var _this = this;
        var name = _a.name, value = _a.value, meta = _a.meta;
        validateNameProperty(name);
        if (!(value || meta)) {
            throw new TypeError('Invalid argument. Either `value` or `meta` property is required.');
        }
        return this.adapter.load(name)
            .then(function (data) {
            if (data === null) {
                throw new KeyEntryDoesNotExistError(name);
            }
            var entry = deserializeKeyEntry(data);
            var updatedEntry = Object.assign(entry, {
                value: value || entry.value,
                meta: meta || entry.meta,
                modificationDate: new Date()
            });
            return _this.adapter.update(name, serializeKeyEntry(updatedEntry))
                .then(function () { return updatedEntry; });
        });
    };
    /**
     * @inheritDoc
     */
    KeyEntryStorage.prototype.clear = function () {
        return this.adapter.clear();
    };
    return KeyEntryStorage;
}());
function serializeKeyEntry(keyEntry) {
    var value = keyEntry.value, rest = __rest(keyEntry, ["value"]);
    var serializableEntry = __assign({}, rest, { value: value.toString('base64') });
    return Buffer.from(JSON.stringify(serializableEntry), 'utf8');
}
function deserializeKeyEntry(data) {
    var dataStr = data.toString('utf8');
    try {
        return JSON.parse(dataStr, function (key, value) {
            if (key === VALUE_KEY) {
                return Buffer.from(value, 'base64');
            }
            if (key === CREATION_DATE_KEY || key === MODIFICATION_DATE_KEY) {
                return new Date(value);
            }
            return value;
        });
    }
    catch (error) {
        throw new InvalidKeyEntryError();
    }
}
function resolveAdapter$1(config) {
    if (typeof config === 'string') {
        return new FileSystemStorageAdapter({ dir: config, name: config });
    }
    var adapter = config.adapter, rest = __rest(config, ["adapter"]);
    if (adapter != null) {
        return adapter;
    }
    return new FileSystemStorageAdapter(__assign({}, DEFAULTS$2, rest));
}
var requiredArg = function (name) { return function (value) {
    if (!value)
        throw new TypeError("Argument '" + name + "' is required.");
}; };
var requiredProp = function (name) { return function (value) {
    if (!value)
        throw new TypeError("Invalid argument. Property " + name + " is required");
}; };
var validateName$1 = requiredArg('name');
var validateNameProperty = requiredProp('name');
var validateValueProperty = requiredProp('value');

/**
 * Class responsible for storage of private keys.
 */
var PrivateKeyStorage = /** @class */ (function () {
    /**
     * Initializes a new instance of `PrivateKeyStorage`.
     * @param {IPrivateKeyExporter} privateKeyExporter - Object responsible for
     * exporting private key bytes from `IPrivateKey` objects and importing
     * private key bytes into `IPrivateKey` objects.
     * @param {IKeyEntryStorage} keyEntryStorage - Object responsible for
     * persistence of private keys data.
     */
    function PrivateKeyStorage(privateKeyExporter, keyEntryStorage) {
        if (keyEntryStorage === void 0) { keyEntryStorage = new KeyEntryStorage(); }
        this.privateKeyExporter = privateKeyExporter;
        this.keyEntryStorage = keyEntryStorage;
    }
    /**
     * Persists the given `privateKey` and `meta` under the given `name`.
     * If an entry with the same name already exists rejects the returned
     * Promise with {@link PrivateKeyExistsError} error.
     *
     * @param {string} name - Name of the private key.
     * @param {IPrivateKey} privateKey - The private key object.
     * @param {Object<string, string>} [meta] - Optional metadata to store with the key.
     *
     * @returns {Promise<void>}
     */
    PrivateKeyStorage.prototype.store = function (name, privateKey, meta) {
        return __awaiter(this, void 0, void 0, function () {
            var privateKeyData, error_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        privateKeyData = this.privateKeyExporter.exportPrivateKey(privateKey);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.keyEntryStorage.save({ name: name, value: privateKeyData, meta: meta })];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        error_1 = _a.sent();
                        if (error_1 && error_1.name === 'KeyEntryAlreadyExistsError') {
                            throw new PrivateKeyExistsError("Private key with the name " + name + " already exists.");
                        }
                        throw error_1;
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Retrieves the private key with the given `name` from persistent storage.
     * If private with the given name does not exist, resolves the returned
     * Promise with `null`.
     *
     * @param {string} name - Name of the private key to load.
     * @returns {Promise<IPrivateKeyEntry|null>}
     */
    PrivateKeyStorage.prototype.load = function (name) {
        return __awaiter(this, void 0, void 0, function () {
            var keyEntry, privateKey;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.keyEntryStorage.load(name)];
                    case 1:
                        keyEntry = _a.sent();
                        if (keyEntry === null) {
                            return [2 /*return*/, null];
                        }
                        privateKey = this.privateKeyExporter.importPrivateKey(keyEntry.value);
                        return [2 /*return*/, {
                                privateKey: privateKey,
                                meta: keyEntry.meta
                            }];
                }
            });
        });
    };
    /**
     * Removes the private key entry with the given `name` from persistent
     * storage.
     *
     * @param {string} name - Name of the private key to remove.
     * @returns {Promise<void>}
     */
    PrivateKeyStorage.prototype.delete = function (name) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.keyEntryStorage.remove(name)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    return PrivateKeyStorage;
}());

export { JwtGenerator, JwtVerifier, Jwt, CachingJwtProvider, CallbackJwtProvider, ConstAccessTokenProvider, GeneratorJwtProvider, CardManager, VirgilCardVerifier, RawSignedModel, ModelSigner, FileSystemStorageAdapter as DefaultStorageAdapter, StorageEntryAlreadyExistsError, KeyStorage, KeyEntryStorage, InvalidKeyEntryError, KeyEntryAlreadyExistsError, KeyEntryDoesNotExistError, PrivateKeyStorage };
